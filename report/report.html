<!DOCTYPE html>
<html>

<head>
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.1.1/normalize.min.css" />
<script src="https://d3js.org/d3.v3.js" charset="utf-8"></script>

<style>
    html {
        background-color: #ffffff;
    }
    body {
        padding: 20px;
    }
    .chart .axis path, .chart .axis line {
        fill: none;
        stroke: #999;
        shape-rendering: crispEdges;
    }
    .chart .axis.x2 path, .chart .axis.x2 line {
        display: none;
    }
    .chart .axis text, .chart .legend text {
        font: 12px sans-serif;
        fill: #333;
    }
    .chart .axis.x path {
        display: none;
    }

    .chart .axis text {
        fill: #555;
    }
    .chart .axis line, .chart .axis path {
        stroke: #888;
    }

    .chart .focus line {
        stroke: #900;
    }
    .chart .focus text {
        fill: #900;
        font: 12px sans-serif;
    }
</style>

<script>
var DEFAULT_COLORS = [
    "#98abc5", "#6b486b", "#ff8c00", "#8a89a6", "#7b6888", "#a05d56", "#d0743c"
];

function _humanFileSize(bytes, si) {
    var thresh = si ? 1000 : 1024;
    if(Math.abs(bytes) < thresh) {
        return bytes + ' B';
    }
    var units = si
        ? ['kB','MB','GB','TB','PB','EB','ZB','YB']
        : ['KiB','MiB','GiB','TiB','PiB','EiB','ZiB','YiB'];
    var u = -1;
    do {
        bytes /= thresh;
        ++u;
    } while(Math.abs(bytes) >= thresh && u < units.length - 1);
    return bytes.toFixed(0)+' '+units[u];
}

function _drawLegend(chart, width, sizes) {
    var legend = chart.selectAll('legend')
            .data(sizes)
            .enter()
                .append("g")
                    .attr('class', 'legend')
                    .attr("transform", "translate(" + width + ", 20)");
    legend.append('circle')
                .style('fill', function(d, i) { return DEFAULT_COLORS[i] })
                .attr('cx', 0)
                .attr('cy', function(d, i) { return i * 20 })
                .attr('r', 5);
    legend.append('text')
                .attr('x', 7)
                .attr('y', function(d, i) { return i * 20 })
                .attr('alignment-baseline', 'central')
                .text(function(d) { return d });
}

function _copyAndSortBenchmarks(benchmarks) {
    var newBench = [];
    Array.prototype.push.apply(newBench, benchmarks);
    newBench.sort(function(e1, e2) {
        return d3.ascending(e1.variations.reduce(function(s, el) {
                                return s+el.qps }, 0),
                            e2.variations.reduce(function(s, el) {
                                return s+el.qps }, 0));
    })
    return newBench
}

function drawBars(elSelector, data, options) {'use strict';
options = options || {};

// geometry

var fullWidth = (options.width || 1000),
    fullHeight = (options.height || 370),
    margin = {top: 10, right: 65, bottom: 55, left: 65},
    width = fullWidth - margin.left - margin.right,
    height = fullHeight - margin.top - margin.bottom,
    benchmarks = _copyAndSortBenchmarks(data.benchmarks);


// data reshape

var maxRps = 0;
benchmarks.forEach(function(bench) {
    bench.variations.forEach(function(v) {
        if (v.qps > maxRps) {
            maxRps = v.qps
        }
    })
});
var sizes = data.querynames;
var names = benchmarks.map(function(d) { return d.title });

// charting

var color = d3.scale.ordinal()
            .range(DEFAULT_COLORS);

var x0 = d3.scale.ordinal()
            .rangeRoundBands([0, width], .2)
            .domain(names);

var x1 = d3.scale.ordinal();
x1.domain(sizes).rangeRoundBands([0, x0.rangeBand()], .2);

var y = d3.scale.linear()
            .range([height, 0])
            .domain([0, maxRps]);

var xAxis = d3.svg.axis()
            .scale(x0)
            .orient("bottom")
            .tickFormat(function(d) { return d.split(' ')[0] });
var xAxis2 = d3.svg.axis()
            .scale(x0)
            .orient("bottom")
            .tickFormat(function(d) { return d.split(' ')[1] });
var xAxis3 = d3.svg.axis()
            .scale(x0)
            .orient("bottom")
            .tickFormat(function(d) { return d.split(' ')[2] });

var yAxis = d3.svg.axis()
            .scale(y)
            .orient("left");

var chart = d3.select(elSelector)
            .attr('viewBox', '0 0 ' + fullWidth + ' ' + fullHeight)
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

chart.append("g")
            .attr("class", "x axis")
            .attr("transform", "translate(0," + height + ")")
            .call(xAxis);

chart.append("g")
            .attr("class", "x axis x2")
            .attr("transform", "translate(0," + (height + 14) + ")")
            .call(xAxis2);

chart.append("g")
            .attr("class", "x axis x2")
            .attr("transform", "translate(0," + (height + 28) + ")")
            .call(xAxis3);

chart.append("g")
            .attr("class", "y axis")
            .call(yAxis)
            .append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 6)
                .attr("dy", ".71em")
                .style("text-anchor", "end")
                .text("Queries / sec");

_drawLegend(chart, width, sizes);

var bench = chart.selectAll(".bench")
            .data(benchmarks)
            .enter().append("g")
                .attr("class", "bench")
                .attr("transform", function(d) {
                    return "translate(" + x0(d.title) + ",0)";
                });

bench.selectAll("rect")
            .data(function(d) { return d.variations; })
            .enter().append("rect")
                .attr("width", x1.rangeBand())
                .attr("x", function(d, i) { return x1(sizes[i]); })
                .attr("y", function(d) { return y(d.qps); })
                .attr("height", function(d) { return height - y(d.qps); })
                .style("fill", function(d, i) { return color(sizes[i]); })
                .on("mouseover", function(d, i) {
                    focusRect
                        .attr('y', y(d.qps) - 9);

                    focusLine
                        .attr('y1', y(d.qps))
                        .attr('y2', y(d.qps));

                    focusText
                        .attr('y', y(d.qps))
                        .text(d3.format("0,000")(Math.round(d.qps)));

                    focus.style("display", null);
                })
                .on("mouseout", function() { focus.style("display", 'none'); });

var focus = chart.append('g')
            .attr('class', 'focus')
            .style('display', 'none');
var focusRect = focus.append('rect')
            .attr('x', -margin.left)
            .attr('width', margin.left - 6)
            .attr('y', 0)
            .attr('height', 18)
            .attr('fill', 'rgba(255, 255, 255, 0.9)');
var focusLine = focus.append('line')
            .attr('x1', -6)
            .attr('x2', width - 20)
            .attr('y1', 0)
            .attr('y2', 0)
            .style("stroke-dasharray", "2,2");
var focusText = focus.append('text')
            .attr('y', 0)
            .attr('x', -9)
            .attr('text-anchor', 'end')
            .attr('alignment-baseline', 'middle');
};


function drawLats(elSelector, data, options) {'use strict';
options = options || {};

// geometry

var fullWidth = (options.width || 1000),
    fullHeight = (options.height || 370),
    margin = {top: 10, right: 65, bottom: 55, left: 65},
    width = fullWidth - margin.left - margin.right,
    height = fullHeight - margin.top - margin.bottom,
    benchmarks = _copyAndSortBenchmarks(data.benchmarks);

// data reshape

var maxLat = 0;
benchmarks.forEach(function(bench) {
    bench.variations.forEach(function(v) {
        if (v.latency_percentiles[4][1] > maxLat) {
            maxLat = v.latency_percentiles[4][1];
        }
    })
});

var sizes = data.querynames;
var names = benchmarks.map(function(d) { return d.title });

// charting

var color = d3.scale.ordinal()
            .range(DEFAULT_COLORS);

var x0 = d3.scale.ordinal()
            .rangeRoundBands([0, width], .2)
            .domain(names);

var x1 = d3.scale.ordinal();
x1.domain(sizes).rangeRoundBands([0, x0.rangeBand()], 0.3);

var y = d3.scale.linear()
            .range([height, 0])
            .domain([0, maxLat]);

var xAxis = d3.svg.axis()
            .scale(x0)
            .orient("bottom")
            .tickFormat(function(d) { return d.split(' ')[0] });
var xAxis2 = d3.svg.axis()
            .scale(x0)
            .orient("bottom")
            .tickFormat(function(d) { return d.split(' ')[1] });
var xAxis3 = d3.svg.axis()
            .scale(x0)
            .orient("bottom")
            .tickFormat(function(d) { return d.split(' ')[2] });


var yAxis = d3.svg.axis()
            .scale(y)
            .orient("left");

var chart = d3.select(elSelector)
            .attr('viewBox', '0 0 ' + fullWidth + ' ' + fullHeight)
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

chart.append("g")
            .attr("class", "x axis")
            .attr("transform", "translate(0," + height + ")")
            .call(xAxis);

chart.append("g")
            .attr("class", "x axis x2")
            .attr("transform", "translate(0," + (height + 14) + ")")
            .call(xAxis2);

chart.append("g")
            .attr("class", "x axis x2")
            .attr("transform", "translate(0," + (height + 28) + ")")
            .call(xAxis3);

chart.append("g")
            .attr("class", "y axis")
            .call(yAxis)
            .append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 6)
                .attr("dy", ".71em")
                .style("text-anchor", "end")
                .text("Latency (msec)");

_drawLegend(chart, width, sizes);

var bench = chart.selectAll(".bench")
            .data(benchmarks)
            .enter().append("g")
                .attr("class", "bench")
                .attr("transform", function(d) {
                    return "translate(" + x0(d.title) + ",0)";
                });

var g = bench.selectAll("rect")
            .data(function(d) { return d.variations; })
            .enter().append("g")
                .attr('class', 'sub');

g.append('line')
            .attr('y1', function(d) { return y(d.latency_percentiles[4][1]); })
            .attr('y2', function(d) { return y(d.latency_percentiles[4][1]); })
            .attr('x1', function(d, i) { return x1(sizes[i]); })
            .attr('x2', function(d, i) { return x1(sizes[i]) + x1.rangeBand(); })
            .style("stroke", function(d, i) { return color(sizes[i]); });

g.append('line')
            .attr('y1', function(d) { return y(d.latency_min); })
            .attr('y2', function(d) { return y(d.latency_min); })
            .attr('x1', function(d, i) { return x1(sizes[i]); })
            .attr('x2', function(d, i) { return x1(sizes[i]) + x1.rangeBand(); })
            .style("stroke", function(d, i) { return color(sizes[i]); });

g.append('line')
            .attr('y1', function(d) { return y(d.latency_percentiles[1][1]); })
            .attr('y2', function(d) { return y(d.latency_percentiles[1][1]); })
            .attr('x1', function(d, i) { return x1(sizes[i]); })
            .attr('x2', function(d, i) { return x1(sizes[i]) + x1.rangeBand(); })
            .style("stroke", function(d, i) { return color(sizes[i]); });

g.append('line')
            .attr('y1', function(d) { return y(d.latency_min); })
            .attr('y2', function(d) { return y(d.latency_percentiles[0][1]) })
            .attr('x1', function(d, i) { return x1(sizes[i]) + x1.rangeBand() / 2; })
            .attr('x2', function(d, i) { return x1(sizes[i]) + x1.rangeBand() / 2; })
            .style("stroke", function(d, i) { return color(sizes[i]); })
            .style("stroke-dasharray", "2,2");

g.append('line')
            .attr('y1', function(d) { return y(d.latency_percentiles[4][1]); })
            .attr('y2', function(d) { return y(d.latency_percentiles[2][1]) })
            .attr('x1', function(d, i) { return x1(sizes[i]) + x1.rangeBand() / 2; })
            .attr('x2', function(d, i) { return x1(sizes[i]) + x1.rangeBand() / 2; })
            .style("stroke", function(d, i) { return color(sizes[i]); })
            .style("stroke-dasharray", "2,2");

g.append('rect')
            .attr('y', function(d) { return y(d.latency_percentiles[2][1]); })
            .attr('x', function(d, i) { return x1(sizes[i]); })
            .attr("width", x1.rangeBand())
            .attr('height', function(d) { return Math.abs(y(d.latency_percentiles[2][1]) - y(d.latency_percentiles[0][1])) })
            .style("stroke", function(d, i) { return color(sizes[i]); })
            .style("fill", 'rgba(0, 0, 0, 0)');

g.append('rect')
            .attr('y', 0)
            .attr('height', height)
            .attr('x', function(d, i) { return x1(sizes[i]); })
            .attr('width', function(d) { return x1.rangeBand(); })
            .style('fill', 'rgba(0, 0, 0, 0)')
            .on("mouseout", function(d, i) {
                d3.select(this).style('fill', 'rgba(0, 0, 0, 0)');
                focus.style('display', 'none');
            })
            .on("mouseover", function(d, i) {
                d3.select(this).style('fill', 'rgba(0, 0, 0, 0.04)');

                var yMedian = y(d.latency_percentiles[1][1]);

                focus
                    .style('display', null);

                focusLine
                    .attr('y1', yMedian)
                    .attr('y2', yMedian);

                    focusRect
                        .attr('y', yMedian - 9);

                    focusLine
                        .attr('y1', yMedian)
                        .attr('y2', yMedian);

                    focusText
                        .attr('y', yMedian)
                        .text(d3.format(".2f")(d.latency_percentiles[1][1]));

            });

var focus = chart.append('g')
            .attr('class', 'focus')
            .style('display', 'none');
var focusRect = focus.append('rect')
            .attr('x', -margin.left)
            .attr('width', margin.left - 6)
            .attr('y', 0)
            .attr('height', 18)
            .attr('fill', 'rgba(255, 255, 255, 0.9)');
var focusLine = focus.append('line')
            .attr('x1', -6)
            .attr('x2', width - 20)
            .attr('y1', 0)
            .attr('y2', 0)
            .style("stroke-dasharray", "2,2");
var focusText = focus.append('text')
            .attr('y', 0)
            .attr('x', -9)
            .attr('text-anchor', 'end')
            .attr('alignment-baseline', 'middle');
};

</script>

<script>
    var DATA = ${__BENCHMARK_DATA__};
</script>

</head>

<body>

<p><em>${__BENCHMARK_DATE__}</em></p>

<h1>EdgeDB Databases Benchmark Report</h1>

Each client is constrained to run in a single process.

<p>Test environment: ${__BENCHMARK_PLATFORM__}.</p>
<p>Duration: ${__BENCHMARK_DURATION__} seconds</p>
<p>Concurrency: ${__BENCHMARK_CONCURRENCY__}</p>

<h2>Results</h2>

<svg id="bars" class="chart" style="width: 80vw"></svg>
<svg id="lats" class="chart" style="width: 80vw"></svg>

<script>
  drawBars('#bars', DATA);
  drawLats('#lats', DATA);
</script>

</body>

</html>
